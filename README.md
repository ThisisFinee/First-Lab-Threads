# Отчеты по лабораторной работе:
## 1.Вычисление числа pi методом Монте-Карло с использованием потоков;
Запуск [./First nthreads ntrials](First.cpp)
### Описание задачи
  Цель данной работы — вычислить приближённое значение числа pi методом Монте-Карло, используя многопоточную обработку данных на языке программирования C++. Задача заключается в симуляции случайных бросков точек в квадрат со стороной 2 и подсчёте, сколько из них попадают в окружность, вписанную в этот квадрат.
 
### Алгоритм программы
  1. Инициализация потоков: Программа принимает два аргумента: количество потоков (nthreads) и общее количество бросков (ntrials). В зависимости от количества потоков общее число итераций делится между потоками.

  2. Генерация случайных точек: Каждый поток генерирует случайные точки внутри квадрата с координатами [−1,1]×[−1,1], и подсчитывает, попадают ли они в окружность радиуса 1, центр которой находится в начале координат. Если точка находится внутри окружности (т.е. x^2+y^2≤1), то это считается попаданием.

  3. Атомарное обновление счётчика попаданий: Результаты каждого потока обновляются атомарно в общем счётчике total_hits, что позволяет избежать ошибок при параллельном доступе к общей переменной.

  4. Вычисление значения pi: После завершения работы всех потоков программа вычисляет приближённое значение pi по формуле.

  5. Замер времени работы: Для анализа производительности программы замеряется время её выполнения для различных количеств потоков.

### Оценка времени работы
  Для оценки времени работы программы на разных количествах потоков были выполнены следующие замеры:

  #### Таблица значений
    | Количество потоков | Общее кол-во попыток | Время выполнения (сек) | Приближённое значение pi |
    |--------------------|----------------------|------------------------|--------------------------|
    | 1                  | 1000000              | 0.228219               | 3.14072                  |
    | 2                  | 1000000              | 0.114358               | 3.14088                  |
    | 3                  | 1000000              | 0.0795927              | 3.14166                  |
    | 4                  | 1000000              | 0.063914               | 3.14091                  |
    | 1                  | 10000000             | 2.22121                | 3.14177                  |
    | 2                  | 10000000             | 1.17708                | 3.1412                   |
    | 3                  | 10000000             | 0.810162               | 3.14166                  |
    | 4                  | 10000000             | 0.631366               | 3.14108                  |

    Очевидный вывод: Программа выполняется быстрее при увелечении числа потоков


### Оценка ускорения и эффективности
  Ускорение показывает, во сколько раз программа с многопоточностью быстрее однопоточной версии. Рассчитывается по формуле:
  S(p)= T(1)/T(p), где T(1) — время выполнения программы на одном потоке, T(p) — время выполнения программы на p потоках. Эффективность показывает, насколько эффективно используются потоки: E(p)= S(p)/p

  #### Таблица ускорения и эффективности для разных значений потоков:
    | Количество потоков | Время выполнения (сек) | Ускорение S(p) | Эффективность E(p) | Общее кол-во попыток |
    |--------------------|------------------------|----------------|--------------------|----------------------|
    | 1                  | 0.228219               | 1.0            | 1.0                | 1000000              |
    | 2                  | 0.114358               | 1.996          | 0.998              | 1000000              |
    | 3                  | 0.0795927              | 2.867          | 0.956              | 1000000              |
    | 4                  | 0.063914               | 3.570          | 0.892              | 1000000              |
    | 1                  | 2.22121                | 1.0            | 1.0                | 10000000             |
    | 2                  | 1.17708                | 1.887          | 0.944              | 10000000             |
    | 3                  | 0.810162               | 2.742          | 0.914              | 10000000             |
    | 4                  | 0.631366               | 3.518          | 0.880              | 10000000             |


  #### Анализ полученных данных
    Ускорение: Программа демонстрирует хорошее ускорение при увеличении количества потоков. Так, на двух потоках ускорение составляет почти 2 (1.996), что говорит о высокой эффективности многопоточности. Также можно увидеть 

    Эффективность: Эффективность постепенно снижается с увеличением количества потоков, что объясняется накладными расходами на управление потоками и синхронизацию данных. Также эффективность  снижается при увелечении кол-ва попыток(в 10 раз), что также может объясняться причиной названной выше.

    Точность: Приближённые значения числа pi, вычисленные программой для разных потоков, находятся в пределах допустимой погрешности.

### Заключение
  Программа для вычисления числа pi методом Монте-Карло продемонстрировала хорошие результаты в части ускорения и эффективности. Для данной задачи наилучшая эффективность была достигнута при использовании 2 потоков. Использование многопоточности позволило значительно ускорить вычисления без значительных потерь в точности, что подтверждает эффективность предложенного решения.
## 2.Множество Мандельброта
Запуск [./Second nthreads ntrials](Second.cpp)
### Алгоритм программы
  1. Инициализация потоков: Программа принимает два аргумента: количество потоков (nthreads) и общее количество бросков (ntrials). В зависимости от количества потоков общее число итераций делится между потоками.

  2. Алгоритм вычисления множества Мандельброта основан на итеративной проверке каждого комплексного числа на принадлежность к множеству. В каждой точке мы запускаем последовательность с начальным значением z_1 = 0 и проверяем, остается ли величина |z_n| меньше 2 на протяжении определённого числа итераций (в данном случае 1000).

  3. Для каждой точки сетки комплексных чисел создается поток, который обрабатывает определенное количество точек. 

  4. Результаты вычислений сохраняются в файл CSV.

  5. Замер времени работы: Для анализа производительности программы замеряется время её выполнения для различных количеств потоков.

### Оценка времени работы
  Для оценки времени работы программы на разных количествах потоков были выполнены следующие замеры:

  #### Таблица значений
    | Количество потоков | Общее кол-во точек | Время выполнения (сек) |
    |--------------------|--------------------|------------------------|
    | 1                  | 500                | 1.20501                |
    | 2                  | 500                | 0.882701               |
    | 3                  | 500                | 0.813321               |
    | 4                  | 500                | 0.780566               |
    | 5                  | 500                | 0.57472                |
    | 6                  | 500                | 0.556589               |
    | 1                  | 1000               | 4.91711                |
    | 2                  | 1000               | 3.51948                |
    | 3                  | 1000               | 3.28291                |
    | 4                  | 1000               | 3.11298                |
    | 5                  | 1000               | 2.40179                |
    | 6                  | 1000               | 2.331                  |

    Очевидный вывод: Программа выполняется немного быстрее при увелечении числа потоков, однако идёт достаточно сильное снижение эффективности(P.s. При использовании 5 потока эффективность )


### Оценка ускорения и эффективности
  Ускорение показывает, во сколько раз программа с многопоточностью быстрее однопоточной версии. Рассчитывается по формуле:
  S(p)= T(1)/T(p), где T(1) — время выполнения программы на одном потоке, T(p) — время выполнения программы на p потоках. Эффективность показывает, насколько эффективно используются потоки: E(p)= S(p)/p

  #### Таблица ускорения и эффективности для разных значений потоков:
    | Количество потоков | Время выполнения (сек) | Ускорение S(p) | Эффективность E(p) | Общее кол-во точек   |
    |--------------------|------------------------|----------------|--------------------|----------------------|
    | 1                  | 1.20501                | 1.0            | 1.0                | 500                  |
    | 2                  | 0.882701               | 1.365          | 0.683              | 500                  |
    | 3                  | 0.813321               | 1.482          | 0.494              | 500                  |
    | 4                  | 0.780566               | 1.544          | 0.386              | 500                  |
    | 5                  | 0.57472                | 2.097          | 0.419              | 500                  |
    | 6                  | 0.556589               | 2.165          | 0.361              | 500                  |
    | 1                  | 4.91711                | 1.0            | 1.0                | 1000                 |
    | 2                  | 3.51948                | 1.397          | 0.699              | 1000                 |
    | 3                  | 3.28291                | 1.498          | 0.499              | 1000                 |
    | 4                  | 3.11298                | 1.580          | 0.395              | 1000                 |
    | 5                  | 2.40179                | 2.047          | 0.409              | 1000                 |
    | 6                  | 2.331                  | 2.109          | 0.352              | 1000                 |


  #### Анализ полученных данных
    Ускорение: Программа демонстрирует небольшое ускорение при увеличении количества потоков. Так, на двух потоках ускорение составляет почти 2 (1.365), что говорит о средней эффективности многопоточности. Также можно увидеть значительные темпы роста ускорения на 5 потоках, с чем это связано сложно сказать.

    Эффективность: Эффективность достаточно быстро снижается с увеличением количества потоков, что объясняется накладными расходами на управление потоками и синхронизацию данных, а также низкой эффективностью многопоточности в данном случае. Эффективность при изменении кол-ва точек почти не изменилась, что говорит о слабом влиянии кол-ва точек на эффективность потока.

### Заключение
  Многопоточность не даёт значительных преимуществ при решении этой задачи(Изначально я подумал, что это может быть исключительно на маленьких данных такая проблема, однако для ./Second 5 5000: 60.1696 seconds, а для ./Second 6 5000: 58.2631 seconds, что показывает низкое влияние кол-ва точек на эффективность)
## 3.Реализация read-write lock
Запуск [.\Third](Third.cpp)
